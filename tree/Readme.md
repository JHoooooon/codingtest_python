# 트리개념

트리는 데이터를 저장하고 탐색하기에 유용한 구조를 가진다

## 트리의 특성을 활용하는 분야

1. 인공지능
2. 자동완성기능
3. DB

## 나무를 거꾸로 뒤집어 놓은 모양의 트리

트리는 나무기둥에서 가지가 뻗어나가는 모습을 거꾸로 뒤집어 놓은 모양이다
나무의 시작인 밑둥은 맨 위에 있다.

- Node: 트리를 구성하는 요소<br/><br/>
- Root Node: 가장 최상단의 `Node` (`Tree` 의 시작점)<br/><br/>
- Edge: `Node` 와 `Node` 를 이어주는 `Node`<br/>이를 통해 몇 Target Node 까지의 경로를 알수 있다<br/>각 거친 경로를 하나당 `Level` 로 표현한다<br/><br/>
- Child & Parent Node: `Edge` 로 연결된 `Node` 들은 부모 자식간의 관계가 이루어진다<br/>`Edge` 로 인해 나누어진 `Node` 를 보면 `Edge Node` 를 부모로,<br/>그 아래의 `Node` 를 `child Node` 로 볼수있다<br/><br/>
- Sibiling Node: 같은 `Level Node` 들을 형재 노드라 한다<br/><br/>
- Leaf Node: 자식이 없는 `Node` 들을 말단 노드라 부른다<br/><br/>
- Degree: 차수란 노트에서 아래로 향하는 간선(`Edge`)의 개수이다<br/>Level 이 3 이라면 `Degree` 는 `3` 이다

## 이진트리

`Degree`(`차수`) 가 최대 `2` 로 이루어진 `Tree` 를 말한다

배열은 선형 자료구조이고, 트리는 계층구조이다
배열로 트리를 표현하려면, `3 가지 규칙` 이 필요하다

- `Root Node` 는 배열 인덱스 `0` 번에 저장
- 왼쪽 자식 노드의 배열 인덱스는 **_부모 노드의 배열 인덱스 x 2 + 1 이다_**
- 오른쪽 자식 노드의 배열 인덱스는 **_부모 노드의 배열 인덱스 x 2 + 2 이다_**

<br/>

- `Root Node` 는 배열 인덱스 `1` 번에 저장
- 왼쪽 자식 노드의 배열 인덱스는 **_부모 노드의 배열 인덱스 x 2 이다_**
- 오른쪽 자식 노드의 배열 인덱스는 **_부모 노드의 배열 인덱스 x 2 + 1 이다_**

배열인덱스가 `0` 인지 `1` 인지에 따라, 적용하는 트리 방식이 약간씩 달라진다

그럼 왼쪽 자식 노드는 짝수로 이루어진 인덱스를 가지며, 오른쪽 자식 노드들을 홀수로 이루어진 인덱스를 가진다

> `Root Node` 가 `1` 번 인덱스일때

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
|     | 1   | 4   | 8   | 3   | 5   |     | 7   | 2   |     |     |     |     |     |     |

트리를 표현한 배열을 보면 빈 값이 꽤 많이 보인다고 한다
이는 노드들의 부모-자식 관계를 곱셈 연산하여 배열의 인덱스로 사용하기 때문이다

이러한 방식은 사용하지 않는 인덱스는 빈값이므로, 희소배열이 된다
배열역시 순차적으로 저장되므로, 빈 배열이 있다는건 메모리 낭비일수 있다

> `Pyhton` 역시 그런지 모르겠지만, 전통적으로 `C` 언어에서는 배열을 순차적으로
> 저장한다. 이말은 메모리가 0 번부터 마지막 인덱스까지 있으면, 메모리 저장공간역시
> 해당 길이만큼 확보해야 한다는 의미이다
>
> 물론 이러한 의미가 아니더라도 빈 인덱스의 값을 가지고 있어야 하므로 메모리 낭비가 맞다.

배열로 트리구조를 만든다는건 이미 구현되어있는 배열을 통해서 만드므로 구현이 쉽지만, 메모리 낭비가 있을수 있음을 알고 있어야 한다

큰 구조의 자료를 저장하는 트리를 구현한다면 좋은 방법은 아니다

> 책에서는 문제 풀이용으로는 나쁘지 않은 선택이라고 한다
>
> 복잡도는 이진 트리의 노드가 `N` 개라면, `O(N)` 이다

## 이진 트리 순회

이진트리 순회는 데이터를 빠짐 없이 방문한다는 것이다
이러한 순회방법은 총 3가지로 이루어진다

순회방법중 전위 순회 먼저 확인해본다

### 전위 순회(`Preorder`)

**현재 노드를 부모 노드로 생각했을때**<br/>`부모노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드` 순으로 방문

> `Root Node` 가 `1` 번 인덱스일때

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
|     | 1   | 4   | 8   | 3   | 5   |     | 7   | 2   |     |     |     |     |     | 6   |

1. 루트 노드에서 시작.<br/>방문 순서는 `1 -> 4 -> 8` 이다<br/> 그러므로, `4` 로 이동한다
   <br/>
2. `4` 를 기준으로 시작한다. <br/> 방문 순서는 `4 -> 3 -> 5` 이다<br/> 그러므로, `3` 으로 이동한다
   <br/>
3. `3` 를 기준으로 시작한다. <br/> 방문 순서는 `3 -> 2 -> None` 이다<br/> 그러므로, `2` 로 이동한다
   <br/>
4. `2` 를 기준으로 시작한다. <br/> `2` 는 다음 `Child Node` 가 없다 <br/> 방문 순서는 부모 `Node` 로 이동한다 <br/><br/> `3 -> 4 -> None` 이다<br/> `3` 은 오른쪽 자식 노드가 `None` 이다. 부모 `Node` 로 이동한다<br/><br/> `4 -> 3 -> 5` 이다.<br/>오른쪽 자식 노드가 `5` 이므로, `5` 로 이동한다
   <br/>
5. `5` 를 기준으로 시작한다.<br/>`5 -> None -> None` 이므로, 자식 노드가 없다<br/>
   부모 노드로 이동한다<br/>`2` 는 탐색을 마쳤으므로, 그 상위 부모인 `1` 로 이동한다
   <br/>`1 -> 4 -> 8` 의 오른쪽 자식 노드인 `8` 로 이동한다
   <br/>
6. `8` 은 `8 -> None -> 7` 이다.<br/> 왼쪽 자식 노드가 `None` 이므로, 그다음인 오른쪽 자식노드인 `7` 로 이동한다.
   <br/>
7. `7` 을 기준으로 시작한다<br/> `7 -> 6 -> None` 이므로, 왼쪽 노드인 `6` 으로 이동한다
   <br/>
8. `6` 을 기준으로 시작한다<br/> `6 -> None -> None` 이므로, 부모노드 `7` 로 이동한다
   <br/>
9. `7` 을 기준으로 시작한다<br/> `7 -> 6 -> None` 이므로, 오른쪽 노드가 없다<br/> 부모 노드 `8` 로 이동한다 <br/> `8 -> None -> 7` 이므로, 오른쪽 노드는 이미 방문했으므로, 부모노드로 이동한다 <br/> `1 -> 4 -> 8` 이므로 오른쪽 노드도 방문했으므로, 모든 노드를 순회했다.

정리해보자면 다음과 같다

1 -> 4 -> 3 -> 2 -> 5 -> 8 -> 7 -> 6 으로 이동하고 순회가 끝난다

### 중위 순회(`Inorder`)

**현재 노드를 부모 노드로 생각했을때**<br/>`왼쪽 자식 노드 -> 부모노드 -> 오른쪽 자식 노드` 순으로 방문

> `Root Node` 가 `1` 번 인덱스일때

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
|     | 1   | 4   | 8   | 3   | 5   |     | 7   | 2   |     |     |     |     |     | 6   |

1. `1` 에서 방문순위는 `4 -> 1 -> 8` 이므로, `4` 로 이동한다
   <br/>

2. `4` 에서 방문순위는 `3 -> 4 -> 5` 이므로, `3` 으로 이동한다
   <br/>

3. `3` 에서 방문순위는 `2 -> 3 -> None` 이므로, `2` 로 이동 방문한다
   <br/>

4. `2` 에서 방문순위는 `None -> 2 -> None` 로 리프노드이므로 방문처리한다.<br/>부모 노드 `3` 으로 이동 방문한다
   <br/>

5. `3` 에서 방문순위는 `2 -> 3 -> None` 이므로, 오른쪽 자식 노드가 없다.<br/>부모 노드 `4` 로 이동 방문한다
   <br/>

6. `4` 에서 방문순위는 `3 -> 4 -> 5` 이므로, 오른쪽 자식 노드인 `5` 로 이동한다
   <br/>

7. `5` 에서 방문 순위는 `None -> 5 -> None` 이므로, 리프노드이므로 방문처리한다<br/> 부모 노드인 `4` 로 이동하며, 왼쪽 자식 노드를 방문했으므로, `1` 로 방문 이동 한다
   <br/>

8. `1` 에서 방문 순위는 `4 -> 1 -> 8` 이므로, 오른쪽 자식 노드인 `8` 로 이동한다
   <br/>

9. `8` 에서 방문 순위는 `None -> 8 -> 7` 이므로, 오른쪽 자식 노드가 없으므로 `8` 을 방문처리하고, 왼쪽 자식 노드인 `7` 로 이동한다
   <br/>

10. `7` 에서 방문순위는 `6 -> 7 -> None` 이므로, 왼쪽 자식 노드인 `6` 으로 이동한다
    <br/>

11. `6` 에서 방문순위는 `None -> 6 -> None` 이므로, 리프 노드이다. <br/> 방문 처리하고 부모노드 `7` 로 이동 방문한다
    <br/>

12. `7` 에서 반문순위는 `6 -> 7 -> None` 이다. 오른쪽 자식노드가 `None` 이므로 부모노드인 `8` 로 이동한다

13. `8` 의 오른쪽 자식 노드를 이미 방문했으므로, 부모 노드인 `1` 로 이동한다

`2 -> 3 -> 4 -> 5 -> 1 -> 8 -> 6 -> 7` 순서로 방문한다
중위순회는 이진 탐색 트리에서 정렬된 순서대로 값을 가져올때 사용된다

### 후위 순회(`Postorder`)

**현재 노드를 부모 노드로 생각했을때**<br/>`왼쪽 자식 노드 -> 오른쪽 자식 노드 ->부모 노드` 순으로 방문

> `Root Node` 가 `1` 번 인덱스일때

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  |
| :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
|     | 1   | 4   | 8   | 3   | 5   |     | 7   | 2   |     |     |     |     |     | 6   |

1. `1` 은 우선순위가 `4 -> 8 -> 1` 이다. `4` 로 이동한다
   <br/>

2. `4` 는 우선순위가 `3 -> 5 -> 4` 이다. `3` 으로 이동한다
   <br/>

3. `3` 은 우선순위가 `2 -> None -> 3` 이다. `2` 으로 이동한다
   <br/>

4. `2` 는 우선순위가 `None -> None -> 2` 이다.<br/>리프 노드이므로 **_`2` 를 방문처리한다_**<br/> 부모노드인 `3` 으로 이동한다
   <br/>

5. `3` 는 우선순위가 `2 -> None -> 3` 이다.<br/>오른쪽 자식노드가 `None` 이므로 **_`3` 을 방문처리한다_**<br/> 부모노드인 `4` 로 이동한다
   <br/>

6. `4` 는 우선순위가 `3 -> 5 -> 4` 이다.<br/>오른쪽 자식노드인 `5` 로 이동한다
   <br/>

7. `5` 는 우선순위가 `None -> None -> 5` 이다.<br/>리프 노드이므로 **_`5` 를 방문처리한다_**<br/> 부모노드인 `4` 로 이동 한다
   <br/>

8. `4` 는 우선순위가 `3 -> 5 -> 4` 이다.<br/>왼쪽, 오른쪽 자식 노드전부 방문처리가 되었으니 **_`4` 를 방문처리한다_**<br/> 부모노드인 `1` 로 이동 한다
   <br/>

9. `1` 은 우선순위가 `4 -> 8 -> 1` 이다.<br/>오른쪽 노드인 `8` 로 이동한다
   <br/>

10. `8` 은 우선순위가 `None -> 7 -> 8` 이다.<br/>오른쪽 노드가 `None` 이므로 `7` 로 이동한다
    <br/>

11. `7` 은 우선순위가 `6 -> None -> 7` 이다.<br/> `6` 으로 이동한다
    <br/>

12. `6` 은 우선순위가 `None -> None -> 6` 이다.<br/> 리프노드이므로 **_`6` 을 방문처리한다_**<br/> 부모노드인 `7` 로 이동한다
    <br/>

13. `7` 은 우선순위가 `6 -> None -> 7` 이다.<br/> 왼쪽 노드가 `None` 이므로 **_`7` 을 방문처리한다_**<br/> 부모노드인 `8` 으로 이동한다
    <br/>

14. `8` 은 우선순위가 `None -> 7 -> 7` 이다.<br/> 오른쪽 노드를 방문했으므로 **_`8` 을 방문처리한다_**<br/> 부모노드인 `1` 로 이동한다
    <br/>

15. `1` 은 우선순위가 `4 -> 8 -> 1` 이다.<br/> 오른쪽 노드를 방문했으므로 **_`1` 을 방문처리한다_**<br/> 부모노드인 `1` 로 이동한다
    <br/>

순회순서는 `2 -> 3 -> 5 -> 4 -> 6 -> 7 -> 8 -> 1` 이다

이러한 후위순회는 자식 노드부터 접근하기에, 트리 삭제시에 활용된다

> 트리는 자식노드가 있어야 유지될수 있다. 중간에 자식 노드가 없다면 유지될수 없다
> 그러므로 트리 삭제시에 자식 노드를 먼저 삭제한후, 부모 노드를 삭제해야 유지될수있다
